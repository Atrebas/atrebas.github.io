---
title: "A data.table and dplyr tour"
author: "Atrebas"
date: "2019-03-03"
summary: data.table and dplyr are two R packages that both aim at an easier and more efficient manipulation of data frames. This article shows how they can be used to execute common data munging tasks. The commands are presented side-by-side to facilitate the comparison.   
output:
  blogdown::html_page:
    toc: true
categories: ["R"]
tags: ["R", "data.table", "dplyr", "data"]
---


```{r  global_options, echo = FALSE}
knitr::opts_chunk$set(results = "hold")
```

```{r echo = FALSE, message = FALSE, warning = FALSE}
library(knitr)
read_chunk('2019-03-03-datatable-dplyr.R')
```

<!----------------------------------------------------------------------------
<div id="contents" style="position:fixed;width: 200px;right:0;top:0">
------------------------------------------------------------------------------->

<script src="/js/jquery-3.3.1.min.js"></script>
<script src="/js/show-hide-console-outputs.js"></script>
<script src="/js/floating-toc.js"></script>


<style>
   table {
      width: 100%;
      border-top: none !important; 
      padding: 0px;
      border-spacing: 2px;
      margin-bottom: 0px;
    }
    td {
      width: 50%;
      text-align: left;
    }
    pre {
    padding: 5px;
    white-space: pre-wrap;
    }
    .hljs.shell{
    background: #ffffff;
    border-style: solid;
    border-width: 1px;
    border-color: #a7a7a71a;
    }
    pre:not(.r) {
    display: none;
    }
    table {
    margin-bottom: 0px;
    table-layout: fixed; 
    }
    .table {
    margin-bottom: 0px;
    }
    h4 {
    text-align: center;
    font-size: 12px;
    font-weight: 600;
    margin-top: 0px;
    margin-bottom: 3px;
    }
    hr.hr2 {
    border: 2px solid #000000;
    }
    .hljs{
    background: #a7a7a71a;
    font-size: 80%;
    word-wrap: break-word;
    }
    #TOC {
    font-size: 12px;
    }
    #TOC.floating {
    position:fixed;
    width: 200px;
    left:0;
    top:0;
    margin-top: 60px;
    }
</style>
 
<!----------------------------------------------------------------------------
                INTRODUCTION
------------------------------------------------------------------------------->

<br>
<table class="table table-condensed"><tbody><tr><td align="center">
![data.table_logo](/images/data.table.png)
</td><td align="center">
![dplyr_logo](/images/dplyr.jpg)
</td></tr></tbody></table>


<br><hr class = "hr2">
# Introduction

### About
- This document is derived from the [Datacamp](https://www.datacamp.com)'s [data.table cheat sheet](https://www.datacamp.com/community/tutorials/data-table-cheat-sheet). 
See the corresponding [courses](https://www.datacamp.com/search?q=data.table).   
- Other useful ressources for data.table can be found on the data.table
[wiki](https://github.com/Rdatatable/data.table/wiki), in the data.table
[vignettes](https://cran.r-project.org/web/packages/data.table/index.html), 
and in the package documentation.   
- Reference documents for dplyr include the dplyr 
[cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf),
the dplyr [vignettes](https://cran.r-project.org/web/packages/dplyr/index.html),
and the package documentation.   
- The idea of presenting data.table and dplyr code side by side has been inspired
by [this stackoverflow question](http://stackoverflow.com/questions/21435339/data-table-vs-dplyr-can-one-do-something-well-the-other-cant-or-does-poorly/27840349#27840349).
- This document has been written for my own self-teaching and may contain 
errors or imprecisions. Corrections and suggestions are welcome.
- For the sake of readability, the console outputs are hidden by default. 
Click on the button below to show or hide the outputs. Also, the R code used in 
this document is independently [available](https://github.com/Atrebas/atrebas.github.io/blob/master/post/2019-03-03-datatable-dplyr.R) and can be easily reproduced.     

<div style="text-align: center;"><input type='button' id='hideshow' value='Show the outputs'></div>


<br><hr>
### data.table and dplyr

data.table and dplyr are two R packages that both aim at an easier and more efficient manipulation of data frames. But while they share a lot of functionalities, their philosophies are quite different. Below is a quick overview of the main differences (from my basic user's perspective).   

__Syntax:__    
- The general data.table syntax is as follows: `DT[i, j, by, ...]` which means: "Take DT, subset rows using `i`, then calculate `j`, grouped by `by`" with possible extra options `...`. It allows to combine several operations in a very concise and consistent expression.    
- The syntax of dplyr is based on five main functions (`filter()`, `arrange()`, `select()`, `mutate()`, `summarise()`) and `group_by()` + their scoped variants (suffixed with `_all`, `_at`, or `_if`) + a bunch of helper functions. It is a 'do one thing at a time' approach, chaining together functions dedicated to a specific task.   

__Ecosystem:__      
The data.table package has no dependency whereas dplyr is part of the tidyverse. So, for example, while data.table includes functions to read, write, or reshape data, dplyr delegates these tasks to companion packages like readr or tidyr.   
On the other hand, data.table is focused on the processing of local in-memory data, but dplyr offers a database backend.   

__Memory management and performance:__    
In data.table, objects can be manipulated 'by reference' (using the `set*()` functions or with the `:=` symbol). It means that the data will be modified but not copied, minimizing the RAM requirements. The behaviour of dplyr is similar to the one of base R.   
Memory management, parallelism, and shrewd optimization give data.table the advantage in terms of performance.   


<br><hr>
### Create example data
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, message=FALSE, warning=FALSE}
<<data1.1>>  
```
</td><td align="left">
```{r, message=FALSE, warning=FALSE}
<<data1.2>>  
```
</td></tr></tbody></table>


Below, the data.table code uses `DT` and the dplyr code uses `DF`. Also, the dplyr code uses the `%>%` operator: a basic knowledge of the [magrittr](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html) syntax is assumed.    



<!----------------------------------------------------------------------------
                             BASIC OPERATIONS
------------------------------------------------------------------------------->

<br><br><hr class = "hr2">
# Basic operations

### Filter rows
#### Filter rows using indices
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<filterRows1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<filterRows1.2>>
```
</td></tr></tbody></table>
#### Discard rows using negative indices
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<filterRows2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<filterRows2.2>>
```
</td></tr></tbody></table>
#### Filter rows using a logical expression 
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<filterRows3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<filterRows3.2>>
```
</td></tr></tbody></table>
#### Filter rows using multiple conditions
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<filterRows4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<filterRows4.2>>
```
</td></tr></tbody></table>
#### Filter unique rows
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<filterRows5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<filterRows5.2>>
```
</td></tr></tbody></table>
#### Discard rows with missing values
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<filterRows6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<filterRows6.2>>
```
</td></tr></tbody></table>
#### Other filters
In addition to the main `filter()` function, dplyr also offers the `filter_all/at/if` variants as well as three helper functions to filter rows. With data.table, we can simply use a custom expression in `DT[i]`.     
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<filterRows7.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<filterRows7.2>>
```
</td></tr></tbody></table>
On the other hand, data.table also provides convenience functions to filter rows based on a regular expression or to find values lying in one (or several) interval(s).      
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<filterRows8.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<filterRows8.2>>
```
</td></tr></tbody></table>
Below, we will see that data.table has two optimized mechanisms to filter rows efficiently (keys and indices).

<br><hr>
### Sort rows
#### Sort rows by column
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<sortRows1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<sortRows1.2>>
```
</td></tr></tbody></table>
#### Sort rows in decreasing order
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<sortRows2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<sortRows2.2>>
```
</td></tr></tbody></table>
#### Sort rows based on several columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<sortRows3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<sortRows3.2>>
```
</td></tr></tbody></table>


<br><hr>
### Select columns
#### Select one column using an index (not recommended)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<selectCols1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<selectCols1.2>>
```
</td></tr></tbody></table>
#### Select one column using column name
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<selectCols2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<selectCols2.2>>
```
</td></tr></tbody></table>
#### Select several columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<selectCols3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<selectCols3.2>>
```
</td></tr></tbody></table>
#### Exclude columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<selectCols4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<selectCols4.2>>
```
</td></tr></tbody></table>
#### Select/Exclude columns using a character vector
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<selectCols5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<selectCols5.2>>
```
</td></tr></tbody></table>
#### Other selections
As for row filtering, dplyr includes helper functions to select column. With data.table, a possible solution is to first retrieve the column names (_e.g._ using a regular expression), then select these columns. Another way (using `patterns()`) is presented in a next section. 
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<selectCols6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<selectCols6.2>>
```
</td></tr></tbody></table>

<br><hr>
### Summarise data

Summary functions take vectors as input and return a single value (_e.g._ `min()`, `mean()`, `var()`, ...).    

#### Summarise one column
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<summarise1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<summarise1.2>>
```
</td></tr></tbody></table>
#### Summarise several columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<summarise2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<summarise2.2>>
```
</td></tr></tbody></table>
#### Summarise several columns and assign column names
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<summarise3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<summarise3.2>>
```
</td></tr></tbody></table>
#### Summarise a subset of rows
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<summarise4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<summarise4.2>>
```
</td></tr></tbody></table>
dplyr helper functions for `summarise()` (or `summarize()`) include `first()`, `last()`, `n()`, `nth()`, and `n_distinct()`. The data.table package also include `first()`, `last()`, and `uniqueN()`.
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<summarise5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<summarise5.2>>
```
</td></tr></tbody></table>

<br><hr>
### Add/update/delete columns
In the following commands, with data.table, columns are modified by reference using the column assignment symbol `:=` (no copy performed) and the results are returned invisibly. With dplyr, we have to assign the results.    

#### Modify a column
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<cols1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<cols1.2>>
```
</td></tr></tbody></table>
#### Add one column
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<cols2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<cols2.2>>
```
</td></tr></tbody></table>
#### Add several columns 
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<cols3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<cols3.2>>
```
</td></tr></tbody></table>
#### Create one column and remove the others
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<cols4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<cols4.2>>
```
</td></tr></tbody></table>
#### Remove one column
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<cols5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<cols5.2>>
```
</td></tr></tbody></table>
#### Remove several columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<cols6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<cols6.2>>
```
</td></tr></tbody></table>
#### Remove columns using a vector of colnames
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<cols7.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<cols7.2>>
```
</td></tr></tbody></table>
#### Replace values for rows matching a condition
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<cols8.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<cols8.2>>
```
</td></tr></tbody></table>


<br><hr>
### by

The `dplyr::group_by()` function and the corresponding `by` and `keyby` statements in data.table allow to run manipulate each group of observations and combine the results. The sole difference between  `by` and `keyby` is that `keyby` orders the results and creates a `key` that will allow faster subsetting (cf. the [indexing and keys](#indexing-and-keys) section). Below, we arbitrary use one or the other.    
Again, the `all-at-if` variants of `group_by()` are available in dplyr but not presented here.    

#### By group
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<by1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<by1.2>>
```
</td></tr></tbody></table>
#### By several groups
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<by2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<by2.2>>
```
</td></tr></tbody></table>
#### Calling function in by
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<by3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<by3.2>>
```
</td></tr></tbody></table>
#### Assigning column name in by
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<by4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<by4.2>>
```
</td></tr></tbody></table>
#### Using a condition in by
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<by5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<by5.2>>
```
</td></tr></tbody></table>
#### By on a subset of rows
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<by6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<by6.2>>
```
</td></tr></tbody></table>
#### Count number of observations for each group
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<by7.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<by7.2>>
```
</td></tr></tbody></table>
#### Add a column with number of observations for each group
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<by8.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<by8.2>>
```
</td></tr></tbody></table>
#### Retrieve the first/last/nth observation for each group
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<by9.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<by9.2>>
```
</td></tr></tbody></table>



<!----------------------------------------------------------------------------
                           GOING FURTHER
------------------------------------------------------------------------------->

<br><br><hr class = "hr2">
# Going further 

### Advanced columns manipulation
To further manipulate columns, dplyr includes nine functions: the `_all`, `_at`, and `_if` versions of `summarise()`, `mutate()`, and `transmute()`.    
With data.table, we use `.SD`, which is a `data.table` containing the Subset of Data for each group, excluding the column(s) used in `by`. So, `DT[, .SD]` is `DT` itself and in the expression `DT[, .SD, by = V4]`, `.SD` contains all the DT columns (except V4) for each values in V4 (see `DT[, print(.SD), by = V4]`). `.SDcols` allows to select the columns included in `.SD`.     

#### Summarise all the columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols1.2>>
```
</td></tr></tbody></table>
#### Summarise several columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols2.2>>
```
</td></tr></tbody></table>
#### Summarise several columns by group
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols3.2>>
```
</td></tr></tbody></table>
#### Summarise with more than one function by group
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols4.2>>
```
</td></tr></tbody></table>
#### Summarise using a condition
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols5.2>>
```
</td></tr></tbody></table>
#### Modify all the columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols6.2>>
```
</td></tr></tbody></table>
#### Modify several columns (dropping the others)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols7.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols7.2>>
```
</td></tr></tbody></table>
#### Modify several columns (keeping the others)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols8.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols8.2>>
```
</td></tr></tbody></table>
#### Modify columns using a condition (dropping the others)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols9.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols9.2>>
```
</td></tr></tbody></table>
#### Modify columns using a condition (keeping the others)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols10.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols10.2>>
```
</td></tr></tbody></table>


The use of `DT[,j]` is very flexible, allowing to pass complex expressions in a straightforward way, or combine expressions with multiple outputs.

#### Use a complex expression
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols11.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols11.2>>
```
</td></tr></tbody></table>
#### Use multiple expressions (with `DT[,{j}]`)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advCols12.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advCols12.2>>
```
</td></tr></tbody></table>


<br><hr>
### Chain expressions
The dplyr workflow relies on the magrittr pipe operator (`%>%`). The magrittr package can also be used with `data.table` objects, but data.table comes with its own chaining system: `DT[ ... ][ ... ][ ... ]`.      

#### Expression chaining using `DT[][]` (recommended)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<chain1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<chain1.2>>
```
</td></tr></tbody></table>
#### Expression chaining using  `%>%` 
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<chain2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<chain2.2>>
```
</td></tr></tbody></table>


<br><hr>
### Indexing and Keys
Row subsetting in dplyr relies on the `filter()` and `slice()` functions, as shown in the first section. With data.table, in addition to the above-mentioned approach, two systems are available to make row filtering and join operations more convenient and blazingly fast (~170x speed-up): _keys_ (primary ordered index) and _indices_ (automatic secondary indexing).    

The main differences between keys and indices are:      
- When using keys, data are physically reordered in memory. When using indices, the order is stored as an attribute.      
- Only one key is possible but several indices can coexist.     
- Keys are defined explicitly. Indices can be created manually but are also created on-the-fly (and stored when using `==` or `%in%`).     
- Indices are used with the `on` argument. It is optional when using keys, but recommended (and used below) for better readability.      
Note: in the following code, we set both a key and an index to demonstrate their usage, but internally, indices are not used when a key already exists for the same columns(s).   


#### Set the key/index   
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key1.2>>
```
</td></tr></tbody></table>
#### Select the matching rows
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key2.2>>
```
</td></tr></tbody></table>
#### Select the first matching row
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key3.2>>
```
</td></tr></tbody></table>
#### Select the last matching row
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key4.2>>
```
</td></tr></tbody></table>
#### Nomatch argument
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key5.2>>
```
</td></tr></tbody></table>
#### Apply a function on the matching rows
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key6.2>>
```
</td></tr></tbody></table>
#### Modify values for matching rows
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key7.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key7.2>>
```
</td></tr></tbody></table>
#### Use keys in by
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key8.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key8.2>>
```
</td></tr></tbody></table>
#### Set keys/indices for multiple columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key9.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key9.2>>
```
</td></tr></tbody></table>
#### Subset using multiple keys/indices
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key10.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key10.2>>
```
</td></tr></tbody></table>
#### Remove keys/indices
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<key11.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<key11.2>>
```
</td></tr></tbody></table>


<br><hr>
### `set*()` modifications
In data.table, `set*()` functions modify objects by reference, making these operations fast and memory-efficient. In case this is not a desired behaviour, users can use `copy()`. The corresponding expressions in dplyr will be less memory-efficient.    

#### Replace values
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<set1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<set1.2>>
```
</td></tr></tbody></table>
#### Reorder rows
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<set2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<set2.2>>
```
</td></tr></tbody></table>
#### Modify colnames
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<set3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<set3.2>>
```
</td></tr></tbody></table>
#### Reorder columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<set4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<set4.2>>
```
</td></tr></tbody></table>
#### Convert data
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<set5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<set5.2>>
```
</td></tr></tbody></table>


<br><hr>
### Advanced use of by

#### Select first/last/... row by group
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advBy1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advBy1.2>>
```
</td></tr></tbody></table>
#### Select rows using a nested query
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advBy2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advBy2.2>>
```
</td></tr></tbody></table>
#### Add a group counter column
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advBy3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advBy3.2>>
```
</td></tr></tbody></table>
#### Get row number of first (and last) observation by group
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advBy4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advBy4.2>>
```
</td></tr></tbody></table>
#### Handle list-columns by group
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advBy5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advBy5.2>>
```
</td></tr></tbody></table>
#### Grouping sets (multiple by at once)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<advBy6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<advBy6.2>>
```
</td></tr></tbody></table>



<!----------------------------------------------------------------------------
                               MISCELLANEOUS
------------------------------------------------------------------------------->

<br><br><hr class = "hr2">
# Miscellaneous

### Read / Write data
`fread()` and `fwrite()` are among the most powerful functions of data.table. They are not only incredibly fast (see [benchmarks](https://www.h2o.ai/blog/fast-csv-writing-for-r/)), they are also extremely robust. 
The few commands below only scratch the surface and there are a lot of awesome features. 
For example, `fread()` accepts `http` and `https` URLs directly as well as operating system commands such as `sed` and `awk` output. Make sure to check the [docs](https://rdrr.io/cran/data.table/man/fread.html).     
Here again, `fread()` and `fwrite()` are very versatile and allow to handle different file formats while dplyr delegates file reading and writing to the readr package with several specific functions (csv, tsv, delim, ...).      

#### Write data to a csv file
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<readwrite1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<readwrite1.2>>
```
</td></tr></tbody></table>
#### Write data to a tab-delimited file
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<readwrite2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<readwrite2.2>>
```
</td></tr></tbody></table>
#### Write list-column data to a csv file
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<readwrite3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<readwrite3.2>>
```
</td></tr></tbody></table>
#### Read a csv / tab-delimited file
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<readwrite4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<readwrite4.2>>
```
</td></tr></tbody></table>
#### Read a csv file selecting / droping columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<readwrite5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<readwrite5.2>>
```
</td></tr></tbody></table>
#### Read and rbind several files
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<readwrite6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<readwrite6.2>>
```
</td></tr></tbody></table>
```{r, eval = TRUE, message = FALSE, warning = FALSE, echo = FALSE, results = "hide"}
<<readwrite7>>
```


<br><hr>
### Reshape data
See [here](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html) and [here](https://tidyr.tidyverse.org/) for more details.

#### Melt data (from wide to long)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<reshape1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<reshape1.2>>
```
</td></tr></tbody></table>
#### Cast data (from long to wide)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<reshape2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<reshape2.2>>
```
</td></tr></tbody></table>
#### Split
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<reshape3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<reshape3.2>>
```
</td></tr></tbody></table>
#### Split and transpose a vector/column
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<reshape4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<reshape4.2>>
```
</td></tr></tbody></table>


<br><hr>
### Other
#### Check package installation
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<other1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<other1.2>>
```
</td></tr></tbody></table>
#### List data.tables/tibbles
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<other2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<other2.2>>
```
</td></tr></tbody></table>
#### Get/Set number of threads when parallelized 
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<other3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<other3.2>>
```
</td></tr></tbody></table>
#### Lead/Lag
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<other4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<other4.2>>
```
</td></tr></tbody></table>
#### Generate run-length ids
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<other5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<other5.2>>
```
</td></tr></tbody></table>
#### Vectorised `ifelse` statements
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<other6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<other6.2>>
```
</td></tr></tbody></table>
#### Rolling functions
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<other7.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<other7.2>>
```
</td></tr></tbody></table>



<!----------------------------------------------------------------------------
                           JOIN/BIND DATA SETS
------------------------------------------------------------------------------->

<br><br><hr class = "hr2">
# Join/Bind data sets

### Join

Joining data in data.table works like the fast subsetting approach described above. It can be performed using keys, using the _ad hoc_ `on` argument, or using the `merge.data.table` method. For the sake of completeness, the three methods are presented below. As previously mentioned, the `on` and `by` (in `merge`) arguments are optional with keyed data.tables, but recommended to make the code more explicit.    
In the examples below, the `x`, `y`, and `z` data.tables are also used with dplyr.    

```{r, eval=TRUE, message=FALSE, warning=FALSE}
<<join1>>
```
#### Join matching rows from y to x
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<join2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<join2.2>>
```
</td></tr></tbody></table>
#### Join matching rows from x to y
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<join3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<join3.2>>
```
</td></tr></tbody></table>
#### Join matching rows from both x and y
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<join4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<join4.2>>
```
</td></tr></tbody></table>
#### Join keeping all the rows
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<join5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<join5.2>>
```
</td></tr></tbody></table>
#### Return rows from x matching y
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<join6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<join6.2>>
```
</td></tr></tbody></table>
#### Return rows from x not matching y
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<join7.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<join7.2>>
```
</td></tr></tbody></table>


<br><hr>
### More joins
data.table excels at joining data, and offers additional functions and features.   

#### Select columns while joining
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins1.2>>
```
</td></tr></tbody></table>
#### Aggregate columns while joining
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins2.2>>
```
</td></tr></tbody></table>
#### Update columns while joining
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins3.2>>
```
</td></tr></tbody></table>
#### Adds a list column with rows from y matching x (nest-join)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins4.2>>
```
</td></tr></tbody></table>
#### Update columns while joining (using vectors of colnames)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins5.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins5.2>>
```
</td></tr></tbody></table>
#### Join passing columns to match in the `on` argument
```{r, eval=TRUE, message=FALSE, warning=FALSE}
<<morejoins6>>
```
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins6.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins6.2>>
```
</td></tr></tbody></table>
#### Non-equi joins
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins7.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins7.2>>
```
</td></tr></tbody></table>
#### Rolling joins/subsets (performed on the last numeric column)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins8.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins8.2>>
```
</td></tr></tbody></table>
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins9.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins9.2>>
```
</td></tr></tbody></table>
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins10.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins10.2>>
```
</td></tr></tbody></table>
#### Cross join (`CJ` ~ `expand.grid`)
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<morejoins11.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<morejoins11.2>>
```
</td></tr></tbody></table>
#### Overlap join
It is important to mention `foverlaps()` from data.table that allows to perform 'overlap joins'. This is an very powerful function, but a bit out of scope for this document. See [these slides](https://raw.githubusercontent.com/wiki/Rdatatable/data.table/talks/EARL2014_OverlapRangeJoin_Arun.pdf) for more details. 


<br><hr>
### Bind
```{r, eval = TRUE, message = FALSE, warning = FALSE}
<<bind1>>
```
#### Bind rows
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<bind2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<bind2.2>>
```
</td></tr></tbody></table>
#### Bind rows using a list
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<bind3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<bind3.2>>
```
</td></tr></tbody></table>
#### Bind columns
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<bind4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<bind4.2>>
```
</td></tr></tbody></table>


<br><hr>
### Set operations
```{r, eval = TRUE, message = FALSE, warning = FALSE}
<<setOps0>>
```
#### Intersection
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<setOps1.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<setOps1.2>>
```
</td></tr></tbody></table>
#### Difference
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<setOps2.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<setOps2.2>>
```
</td></tr></tbody></table>
#### Union
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<setOps3.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<setOps3.2>>
```
</td></tr></tbody></table>
#### Equality
<table class="table table-condensed"><tbody><tr><td align="left">
```{r, eval=TRUE}
<<setOps4.1>>
```
</td><td align="left">
```{r, eval=TRUE}
<<setOps4.2>>
```
</td></tr></tbody></table>



<!----------------------------------------------------------------------------
                                 SUMMARY
------------------------------------------------------------------------------->

<br><br><hr class = "hr2">
# Summary

This article presented the most important features of both data.table and dplyr, two packages that are now essential tools for data manipulation in R.      
There are still a lot of features not covered in this document, in particular, data.table functions to deal with time-series or dplyr vectorized functions have not been discussed, but 'done is better than perfect'...     
Hopefully, this comparison is not too biased, but I must admit that my preference is for data.table. So, I hope this post will encourage some readers to give it a try!    
<hr>

```{r, eval = TRUE, message = FALSE, warning = FALSE}
<<sessionInfo>>
```


